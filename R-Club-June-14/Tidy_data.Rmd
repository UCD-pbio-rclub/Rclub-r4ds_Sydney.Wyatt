---
title: "Chapter 12 Tidy data"
output: 
  html_document: 
    keep_md: yes
---

```{r, include=FALSE}
library(tidyverse)
```

## 12.2 Tidy data

3 rules to make data tidy:  
1. Each variable must have own column  
2. Each observation must have own row  
3. Each value must have own cell  

Why make it tidy? There's an advantage to picking one consistent way of storing data. There's a specific advantage to placing variables in columns because it allows R's vectorised nature to shine. Most built-in R funcions work with vectors.  

### 12.2.1 Exercises  

**1. Using prose, describe how the variables and observations are organised in each of the sample tables.**  

**2. Compute the `rate` for `table2` and `table4a + table4b`. You will need to perform four operations:**  
**1. Extract the number of TB cases per country per year.**  
**2. Extract the matching population per country per year.**  
**3. Divide cases by population, and multiply by 10,000.**  
**4. Store back in the appropriate place.**  **Which representation is easiest to work with? Which is hardest? Why?**  

**3. Recreate the plot showing change in cases over time using `table2` instead of `table1`. What do you need to do first?**  


## 12.3 Spreading and gathering

For most real analyses there will be need for tidying - one variable might be spread across multiple columns or one observation might be scattered across multiple rows. Two most important functions: `gather()` and `spread()`.  

### 12.3.1 Gathering  

A common problem is where some of the column names are not names oof variables but _values_ of a variable. In `table4a` the columns `1999` and `2000` are values of the `year` variable and each row represents two observations. We need to gather the columns into a new pair of variables. There are three parameters that need to be described:  
* The set of columns that represent values not variables. In this example, those are `1999` and `2000`.  
* The name of the variable whose values form the column names. This is the `key` and here it is `year`.  
* The name of he variable whose values are spread over the cells. This is called `value` and here it is the number of `cases`.  

The code would look like:  
```{r}
# table4a %>% gather(`1999`, `2000`, key="year". value="cases")
```

The columns to gather are specified with `dplyr::select()` style notation.What about for `table4b`?  
```{r}
# table4b %>% gather(`1999`, `2000`, key="year", value="population")
```

To combine the tidied versions into a single tibble, use `dplyr::left_join()`:  
```{r}
# tidy4a <- table4a %>% 
#  gather(`1999`, `2000`, key = "year", value = "cases")
#tidy4b <- table4b %>% 
#  gather(`1999`, `2000`, key = "year", value = "population")
#left_join(tidy4a, tidy4b)
```

### 12.3.2 Spreading  

Spreading is the opposite of gathering. In `table2` an observation is a country in a year but each observation is spread across two rows. There are two parameters needed:  
* The column that contains variable names is the `key` column. In `table2` it is `type`.  
* The column that contains values forms multiple variables is the `value` column. In `table2` it is `count`.  

Example:  
```{r}
# spread(table2, key=type, value=count)
```


`spread()` and `gather()` are complements. `gather()` makes wide tables narrower and longer; `spread()` makes long tables shorter and wider.  

### 12.3.3 Exercises  

**1. Why are `gather()` and `spread()` not perfectly symmetrical? Carefully consider the following example:**  
```{r}
stocks <- tibble(
  year = c(2015, 2015, 2016, 2016),
  half = c(   1,    2,     1,    2),
  return = c(1.88, 0.59, 0.92, 0.17)
)

stocks %>% 
  spread(year, return) %>% 
  gather("year", "return", `2015`:`2016`)
```

**(Hint: look at the variable types and think about column names.)**  
**Both `spread()` and `gather()` have a `convert` argument. What does it do?**  

**2. Why does this code fail?**  
```{r}
table4a %>% gather(1999, 2000, key="year", value="cases")
```

**3. Why does spreading this tibble fail? How could you add a nw column to fix the problem?**  
```{r}
people <- tribble(
   ~name,             ~key,    ~value,
  #-----------------|--------|------
  "Phillip Woods",   "age",       45,
  "Phillip Woods",   "height",   186,
  "Phillip Woods",   "age",       50,
  "Jessica Cordero", "age",       37,
  "Jessica Cordero", "height",   156
)
```

**4. Tidy the simple tibble below. Do you need to spread or gather it? What are the variables?**  
```{r}
preg <- tribble(
  ~pregnant, ~male, ~female,
  "yes",     NA,    10,
  "no",      20,    12
)
```


## 12.4 Separating and uniting  

`table3` has one column `rate` that contains two variables `cases` and `population`. TO tidy this table, use `separate()`. If there was a single variable spread across multiple columns use `unite()` to tidy it.  

### 12.4.1 Separate  

`separate()` pulls apart one column into multiple columns by splitting wherever a separator character appears. For `table3`, the `rate` column contains both `cases` and `population` variables. `separate()` takes the name of the column to separate, and the names of the columns to separate into:  
```{r}
# table3 %>% separate(rate, into=c("cases", "population"))
```

By default, `separate()` will split values wherever it sees a non-alphanumeric character. You can specify the character if you want with `sep = "/"`. The default behavior of `separate()` leaves the type of the column as is. So `case` and `population` are left as character columns. We can change this with `convert = TRUE`. We can also give `sep` a vector of integers. The function will interpret them as positions to split at. Positive values start at 1 on the far-left of the strings; negative values start at -1 on the far-right. When using integers to separate strings, the length of `sep` should be one less than the number of names in `into`.  

### 12.4.2 Unite  

`unite()` is the inverse of `separate()` and is used less often. It combines multiple columns into a single column:  
```{r}
table5 %>% 
  unite(new, century, year)
```

Here we also need to use the `sep` argument. The default places an underscore between the values from different columns.  
```{r}
table5 %>% 
  unite(new, century, year, sep = "")
```

### 12.4.3 Exercises  

**1. What do the `extra` and `fill` arguments do in `separate()`? Experiment with the various options for the following two toy datasets.**  
```{r}
tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %>% 
  separate(x, c("one", "two", "three"))

tibble(x = c("a,b,c", "d,e", "f,g,i")) %>% 
  separate(x, c("one", "two", "three"))
```

**2. Both `unite()` and `separate()` have a `remove` argument. What does it do? Why would you set it to `FALSE`?**  

**3. Compare and contrast `separate()` and `extract()`. Why are there three variations of separation (by position, by separator, and with groups), but only one unite?**